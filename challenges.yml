# Extending
extending_inheritfunctionalitycoding:
    question: |
        Your team has been working hard building the `DeathStar` class, only
        to find out that the Rebels have just destroyed it! Time to rebuild!
        
        Long live the Empire!
    question_steps:
        - |
          Create a new class called `DeathStarII` in the `DeathStarII.php` file
          and make it inherit all of the functionality from the original `DeathStar`.
        - In `index.php`, instantiate a new `DeathStarII` object and set it to a `$deathStar` variable.
        
    step: extending-inherit-functionality
    files:
        index.php: ~
        DeathStarII.php: ~
        DeathStar.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_variable:
            type: php
            assertTrue: variable_exists('deathStar')
            failure: Make sure the `$deathStar` variable is exist
        assert_instance_of_1:
            type: php
            assertTrue: get_class(variable('deathStar')) === 'DeathStarII'
            failure: The `$deathStar` variable exists, but is not set to a `DeathStarII` object.
        assert_instance_of_2:
            type: php
            assertTrue: is_subclass_of(variable('deathStar'), '\DeathStar')
            failure: The `DeathStarII` class is not extending `DeathStar` one.

extending_callnonexistentmethodmc:
    question: |
        Look at these two classes:

        ```php
        class Ship
        {
            public function getName()
            {
                return 'Starfighter';
            }
        }
        ```

        ```php
        class JediShip extends Ship
        {
            public function getFavoriteJedi()
            {
                return 'Yoda';
            }
        }
        ```

        Suppose we instantiate both objects:

        ```php
        $ship = new Ship();
        $jediShip = new JediShip();
        ```

        Which of the following lines will cause an error?
    explanation: |
        The `Ship` object does *not* have a `getFavoriteJedi()` method
        on it - only `JediShip` has this. But, since `JediShip extends Ship`,
        the `JediShip` *does* have a `getName()` method: it inherits it from
        `Ship`.
    features:
        multiple_choice:
            choices:
                a: |
                    ```php
                    echo $ship->getName();
                    ```
                b: |
                    ```php
                    echo $ship->getFavoriteJedi();
                    ```
                c: |
                    ```php
                    echo $jediShip->getName();
                    ```
                d: Both (B) and (C) will cause an error
            correct: b

# Override
override_overrideinheritmethodcoding:
    question: |
        Well, we learned some hard lessons after the destruction of the original `DeathStar`,
        and we don't want to repeat them!
    question_steps:
        - Override the `getWeakness()` method in `DeathStarII` and make it return `null`. Phew, problem solved!
    step: override-override-inherited-method
    files:
        DeathStarII.php: ~
        index.php:
            read_only: true
        DeathStar.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        assert_method:
            type: php
            assertTrue: variable('new').getWeakness() === null
            failure: The `getWeakness()` method of `DeathStarII` class does not return `null`.

override_calloverriddenmethodmc:
    question: |
        Look at the following classes:

        ```php
        class Ship
        {
            public function printType()
            {
                echo 'Empire Ship';

                $this->printMotto();
            }

            public function printMotto()
            {
                echo 'I like to fly!';
            }
        }
        ```

        ```php
        class RebelShip extends Ship
        {
            public function printType()
            {
                echo 'Rebel Ship';
            }
        }
        ```

        What is the result of the following code:

        ```php
        $ship = new Ship();
        $rebelShip = new RebelShip();
        $ship->printType();
        $rebelShip->printType();
        ```
    explanation: |
        For `Ship`, `printType()` prints "Empire Ship" and then also
        calls `printMotto()`. But for `RebelShip`, `printType()` only
        prints "Rebel Ship". *Nothing* calls the `printMotto()`
        function in this case.
    features:
        multiple_choice:
            choices:
                a: Empire ShipRebelShip
                b: Empire ShipI like to fly!RebelShip
                c: Empire ShipI like to fly!RebelShipI like to fly
                d: RebelShipRebelShip
            correct: b

# ProtectedVisibility
protectedvisibility_getinheritedpropertycoding:
    question: |
        The construction of the `DeathStarII` continues, but we need access
        to the `planetarySuperLaserRange` property from the original, because
        we're going to make it fire twice as far!
    question_steps:
        - Fix the `DeathStar` class so that the new `getSpecs()` method works
    step: protected-visibility-get-inherited-property
    files:
        DeathStar.php: ~
        DeathStarII.php:
            read_only: true
        index.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_property:
            type: php
            assertTrue: reflection_class('\DeathStar').hasProperty('planetarySuperLaserRange')
            failure: The `planetarySuperLaserRange` property does not exist in the `DeathStar` class.
        check_property_visibility:
            type: php
            assertTrue: reflection_class('\DeathStar').getProperty('planetarySuperLaserRange').isProtected()
            failure: The `planetarySuperLaserRange` property should have protected visibility.

protectedvisibility_propertyvisibilitymc:
    question: |
        Check out the following code:

        ```php
        // Ship.php

        class Ship
        {
            public $name;

            protected $weaponPower;

            private $defense;

            public function getDefense()
            {
                return $this->defense;
            }
        }
        ```

        ```php
        // JediShip.php

        class JediShip extends Ship
        {
            public function getWeaponPower()
            {
                return $this->weaponPower;
            }
        }
        ```

        ```php
        // index.php

        $jediShip = new JediShip();
        $jediShip->name;
        $jediShip->weaponPower;
        ```

        Which of the above code will give us an error?
    explanation: |
        Since the `$defense` property is `private`, we can only access it from
        within the `Ship` class. But that's exactly what we're doing in (B),
        so that's fine.

        The `$weaponPower` property is `protected`. That means we can access it
        only from inside `Ship`, `JediShip` or any other sub-classes. That's why
        (C) is valid. But in (A), we're accessing `weaponPower` from `index.php`.
        Accessing a property or method from outside of the class is only allowed
        if it is public. This is a bad code.
    features:
        multiple_choice:
            choices:
                a: '`$jediShip->weaponPower` in `index.php`'
                b: '`return $this->defense` in `Ship.php`'
                c: '`return $this->weaponPower` in `JediShip.php`'
                d: None of the above is bad code - we're awesome!
            correct: a

# Parent
parent_callparentmethodcoding:
    question: |
        It took too long to travel to planets to destroy them
        in the first DeathStar, so Darth wants the laser range
        on the new DeathStar to be *twice* as far! Brilliant!
    question_steps:
        - |
          Override the `getLaserRange()` method in `DeathStarII` to make
          this happen. (But don't repeat the `2000000` value!)
        - Call the parent function and then multiply that value by 2!
    step: parent-call-parent-method
    files:
        DeathStarII.php: ~
        DeathStar.php:
            read_only: true
        index.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_method:
            type: php
            assertTrue: method_exists(variable('deathStar'), 'getLaserRange')
            failure: The `getLaserRange()` method does not exist for the `DeathStarII` class - did you create it?
        assert_method:
            type: php
            assertTrue: 4000000 === variable('deathStar').getLaserRange()
            failure: The `getLaserRange()` method in the `DeathStarII` class should return a doubled value of the parent method.

# AbstractShip
abstractship_extendabstractclasscoding:
    question: |
        We've just gotten word that the Rebels have *also*
        destroyed the `DeathStarII`. Wow, rotten luck. Anyways,
        it sounds like we'll be creating blue prints for many
        different types of DeathStars in the future, to keep
        the Rebels guessing.

        To make this easier... 
    question_steps:
        - Create an `AbstractDeathStar` class and move all of the shared code into it.
        - | 
          Update `DeathStar` and `DeathStarII` to extend this new class and make sure to get rid of anything in those classes
          that you've moved into the new parent class.
    step: abstract-ship-extend-abstract-class
    files:
        AbstractDeathStar.php: ~
        DeathStar.php: ~
        DeathStarII.php: ~
        index.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_class:
            type: php
            assertTrue: class_exists('\AbstractDeathStar')
            failure: The `AbstractDeathStar` class does not exist! Did you create it?
        assert_abstract:
            type: php
            assertTrue: reflection_class('\AbstractDeathStar').isAbstract()
            failure: The `AbstractDeathStar` class should be declared as abstract.
        check_methods:
            type: php
            assertTrue: reflection_class('\AbstractDeathStar').hasMethod('setWeaponPower') and reflection_class('\AbstractDeathStar').hasMethod('getWeaponPower') and reflection_class('\AbstractDeathStar').hasMethod('makeFiringNoise')
            failure: The `AbstractDeathStar` class should have `getWeaponPower()`, `setWeaponPower()`, and `makeFiringNoise()` methods.
        check_method:
            type: php
            assertFalse: reflection_class('\AbstractDeathStar').hasMethod('setCrewSize')
            failure: The `AbstractDeathStar` class should not have a `setCrewSize()` method! The `DeathStarII` just has a hardcoded crew size, so does not need this setter. Move it to `Deathstar`.
        assert_subclass_of:
            type: php
            assertTrue: reflection_class('\DeathStar').isSubclassOf('\AbstractDeathStar') and reflection_class('\DeathStarII').isSubclassOf('\AbstractDeathStar')
            failure: The both `DeathStar` and `DeathStarII` classes should extend `AbstractDeathStar` one.

abstractship_inheritanceoverheadmc:
    question: |
        A co-worker created a few classes and has asked for
        your advice about organizing them:

        ```php
        class Ship
        {
            private $name;

            public function getName()
            {
                return $name;
            }

            public function setName($name)
            {
                $this->name = $name;
            }

            // other stuff...
        }
        ```

        ```php
        class Person
        {
            private $name;

            public function getName()
            {
                return $name;
            }

            public function setName($name)
            {
                $this->name = $name;
            }

            // other stuff...
        }
        ```

        Your teammate is wondering if this can be organized better.
        Which if the following is the best advice?
    explanation: |
        Even though both classes share some code, a `Ship`
        and a `Person` fundamentally aren't the same thing,
        and probably don't have any other overlapping code.
        So, you *could* create an `AbstractNamedItem`, but
        that's a bit awkward. And remember, you can only
        extend *one* class, so make sure your parent class
        makes sense.

        In this case, the best action is to do nothing: leave
        these two blueprints totally independent. In a future
        episode, we'll talk about traits: a cool way to help
        remove duplication without inheritance.
    features:
        multiple_choice:
            choices:
                a: |
                    Create a new `AbstractNamedItem` class that has the
                    `name` property and the `getName()` and `setName()`
                    methods. Then, make `Person` and `Ship` extend this
                    class.
                b: |
                    Make `Ship` extend `Person`, and remove all the
                    duplicated code in `Person`.
                c: |
                    Leave things exactly like they are now.
            correct: c

# AddingAbstract
addingabstract_functiontypehintwithclassnamemc:
    question: |
        Check out these classes that the intern created,
        which all have confusing names:

        ```php
        abstract class OtherClass extends GreatClass
        {
        }
        ```

        ```php
        abstract class SomeClass extends OtherClass
        {
        }
        ```

        ```php
        class GreatClass
        {
        }
        ```

        ```php
        class MyClass extends OtherClass
        {
        }
        ```

        ```php
        class Puppy extends SomeClass
        {
        }
        ```

        ```php
        function doSomething(OtherClass $thing)
        {
            // ...
        }
        ```

        Based on the type-hint, objects of which classes could be passed
        to the `doSomething()` function?
    explanation: |
        Since the type-hint is `OtherClass`, any `OtherClass` object or sub-classes
        are accepted. The sub-classes are `MyClass` and `SomeClass` (directly)
        and also `Puppy` (though `SomeClass`). But we can instantiate objects
        *only* of `MyClass` and `Puppy` classes, because `OtherClass` and `SomeClass`
        are abstract!
    features:
        multiple_choice:
            choices:
                a: '`OtherClass` and `SomeClass`'
                b: '`OtherClass` and `MyClass`'
                c: '`MyClass` and `Puppy`'
                d: '`OtherClass` and `GreatClass`'
            correct: c

addingabstract_createabstractmethodcoding:
    question: |
        When Darth is browsing all the different `DeathStar` models, we want to print
        out a little description that describes each one. Inside of that description,
        we want to include the "laser range", but it's different based on the model.
    question_steps:
        - Create an abstract method called `getLaserRange()` in `AbstractDeathStar`.
        - Use that in `getDescription()` to set the `$range` variable.
        - Make sure the `DeathStar` class has range = 500.
        - Lastly, make sure the `DeathStarII` class has range = 900.
    step: adding-abstract-create-abstract-method
    files:
        AbstractDeathStar.php: ~
        DeathStarII.php: ~
        DeathStar.php: ~
        index.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        look_for_method:
            type: php
            assertTrue: reflection_class('\AbstractDeathStar').hasMethod('getLaserRange')
            failure: Method `getLaserRange()` does not exist in the `AbstractDeathStar` class. Did you create it?
        assert_abstract:
            type: php
            assertTrue: reflection_class('\AbstractDeathStar').getMethod('getLaserRange').isAbstract()
            failure: Method `getLaserRange()` declared in the `AbstractDeathStar` class should be abstract.
        assert_method_value:
            type: php
            assertTrue: 500 == variable('deathStar').getLaserRange() and 900 == variable('deathStar2').getLaserRange()
            failure: Method `getLaserRange()` should return `500` for the `DeathStar` class and `900` for the `DeathStarII`.
        assert_method_call:
            type: php
            assertTrue: inputContains('AbstractDeathStar.php', '->getLaserRange')
            failure: Did you call `getLaserRange()` method in the `AbstractDeathStar` class?
        check_output:
            type: http
            assertTrue: body() matches '/500/' and body() matches '/900/'
            failure: I don't see laser ranges in the output - did you print it?

# BrokenShip
brokenship_createdeathstariiicoding:
    question: |
        I feel like we're *always* designing new DeathStars. Well, no time to complain
        time to start the DeathStarIII!
    question_steps:
        - Create a new `DeathStarIII` class, make it extend `AbstractDeathStar`, and fill in any missing abstract methods. 
        - Lastly, print out the description in `index.php`.
    step: broken-ship-create-deathstartiii-class
    files:
        index.php: ~
        DeathStarIII.php: ~
        AbstractDeathStar.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        assert_subclass_of:
            type: php
            assertTrue: reflection_class('\DeathStarIII').isSubclassOf('\AbstractDeathStar')
            failure: The `DeathStarIII` class should extend the `AbstractDeathStar` one.
        look_for_variable:
            type: php
            assertTrue: variable_exists('deathStar3')
            failure: I don't see the `$deathStar3` variable in `index.php` - did you create it?
        assert_instance_of:
            type: php
            assertTrue: get_class(variable('deathStar3')) === 'DeathStarIII'
            failure: The `$deathStar3` variable exists, but is not set to a `DeathStarIII` object.
        look_for_text:
            type: http
            assertTrue: css('h3').text() matches '/with a range of/'
            failure: Hmm, did you print the `DeathStarIII` description in the `h3` tag?
        assert_number:
            type: http
            assertTrue: css('h3').text() matches '/with a range of [0-9]+/'
            failure: The `getLaserRange()` method on `DeathStarIII` class must returns a number.

# PdoShipStorage
pdoshipstorage_decomposestringtransformercoding:
    question: |
        Tired from working on the DeathStar, you challenged the intern (let's call her
        "Morgan") to create a class that can reverse a string and upper case every other letter.
        "Ha!" Morgan says, "This is simple!". To show off, Morgan creates the `StringTransformer`
        class and *even* makes it cache the results to be super-performant.

        But wait you say! Combining the string transformation *and* caching into the same
        class make `StringTransformer` responsible for two jobs. Help show Morgan the intern
        a better way.
    question_steps:
        - Creating a new `Cache` class with two methods `fetchFromCache($key)` and `saveToCache($key, $val)`. 
        - Then, pass this into `StringTransformer` and use it to cache, instead of using your own logic.
    step: pdo-ship-storage-decompose-string-transformer
    files:
        index.php: ~
        StringTransformer.php: ~
        Cache.php: ~
    features:
        editor: ~
        browser: ~
    grading:
        check_class:
            type: php
            assertTrue: class_exists('\Cache')
            failure: Class `Cache` does not exist. Did you create it?
        check_method:
            type: php
            assertTrue: reflection_class('\Cache').hasMethod('fetchFromCache')
            failure: Method `fetchFromCache()` does not exist in the `Cache` class.
        check_method:
            type: php
            assertTrue: reflection_class('\Cache').hasMethod('saveToCache')
            failure: Method `saveToCache()` does not exist in the `Cache` class.
        check_variable:
            type: php
            assertTrue: variable_exists('transformer')
            failure: I don't see the `$transformer` variable in `index.php` anymore - did you delete it?
        assert_variable:
            type: php
            assertTrue: get_class(variable('transformer')) === 'StringTransformer'
            failure: Make sure you give the `StringTransformer` class a `__construct()`. It should have one argument - a `Cache` object.
        assert_method:
            type: php
            assertTrue: reflection_class('\StringTransformer').hasMethod('__construct')
            failure: Make sure you give the `StringTransformer` class a `__construct()`. It should have one argument - a `Cache` object.
        look_for_function:
            type: http
            assertFalse: body() matches '/file_get_contents/'
            failure: I still see `file_get_contents()` inside of `StringTransformer`. Make sure you've moved all of the caching logic into the Cache class.
        # @TODO Create a mocked Cache, pass it into
        # @TODO $transformer and assert that its cache methods are called

pdoshipstorage_stringtransformerdecompositionadvantagesmc:
    question: |
        In the previous challenge, you split the logic from `StringTransformer`
        into two different classes. What are the advantages of this?
    explanation: |
        All of these are advantages! Before, you might not even realize that
        the `StringTransformer` had caching logic, but now its very obvious:
        the caching logic is in a class called `Cache` and you can see that
        the `StringTransformer` requires a `Cache` object. You could also use
        the `Cache` class in other situations to cache other things. And you
        could even - with a little bit of work - create a new `Cache` class
        that caches via something like Redis, and pass *this* to `StringTransformer`
        to cache using a different method.
    features:
        multiple_choice:
            choices:
                a: Each class is smaller and so easier to understand
                b: The `Cache` class could be re-used to cache other things
                c: You could easily use the `StringTransformer`, but cache using a different mechanism, like *Redis*
                d: All of these are real advantages
            correct: d

# AbstractShipLoader
abstractshiploader_createabstractplanetcoding:
    question: |
        Annoyed that the DeathStars are being destroyed, the Empire has decided to transform into
        a video game company. Awesome, they'll never see it coming! Two different teammates have 
        already created two classes to model this: `SolidPlanet` and `GasPlanet`. They look and 
        work differently, but both have `getRadius()` and `getHexColor()` methods. You've built a 
        `PlanetRenderer` class with a `render()` method, but it's not quite working yet.
    question_steps:
        - Create an `AbstractPlanet` class and update any other code you need to make these planets render!
    step: abstract-ship-loader-create-abstract-planet
    files:
        AbstractPlanet.php: ~
        SolidPlanet.php: ~
        GasPlanet.php: ~
        PlanetRenderer.php: ~
        index.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_class:
            type: php
            assertTrue: class_exists('\AbstractPlanet')
            failure: Class `AbstractPlanet` does not exist! Did you create it?
        assert_class_abstract:
            type: php
            assertTrue: reflection_class('\AbstractPlanet').isAbstract()
            failure: Class `AbstractPlanet` should be declared as abstract.
        check_method_1:
            type: php
            assertTrue: reflection_class('\AbstractPlanet').hasMethod('getRadius')
            failure: Method `getRadius()` does not exist in the `AbstractPlanet` class.
        assert_method_1_abstract:
            type: php
            assertTrue: reflection_class('\AbstractPlanet').getMethod('getRadius').isAbstract()
            failure: Method `getRadius()` should be declared as abstract.
        check_method_2:
            type: php
            assertTrue: reflection_class('\AbstractPlanet').hasMethod('getHexColor')
            failure: Method `getHexColor()` does not exist in the `AbstractPlanet` class.
        assert_method_2_abstract:
            type: php
            assertTrue: reflection_class('\AbstractPlanet').getMethod('getHexColor').isAbstract()
            failure: Method `getHexColor()` should be declared as abstract.
        check_subclass_of_1:
            type: php
            assertTrue: reflection_class('\SolidPlanet').isSubclassOf('\AbstractPlanet')
            failure: Class `SolidPlanet` should inherit the `AbstractPlanet` one.
        check_subclass_of_2:
            type: php
            assertTrue: reflection_class('\GasPlanet').isSubclassOf('\AbstractPlanet')
            failure: Class `GasPlanet` should inherit the `AbstractPlanet` one.

# Interfaces
interfaces_implementplanetinterfacecoding:
    question: |
        After watching this last episode, you realize that `AbstractPlanet` should really
        be an interface. I've given you a head start by creating the `PlanetInterface`.
    question_steps:
        - Update all of your code to use it and get these planets rendering again!
    step: interfaces-implement-planetinterface
    files:
        SolidPlanet.php: ~
        GasPlanet.php: ~
        PlanetRenderer.php: ~
        PlanetInterface.php:
            read_only: true
        index.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        assert_implementing_1:
            type: php
            assertTrue: reflection_class('\SolidPlanet').implementsInterface('\PlanetInterface')
            failure: Class `SolidPlanet` should implement the `PlanetInterface` interface.
        assert_implementing_2:
            type: php
            assertTrue: reflection_class('\GasPlanet').implementsInterface('\PlanetInterface')
            failure: Class `GasPlanet` should implement the `PlanetInterface` interface.

interfaces_interfacevsabstractclassmc:
    question: |
        You over-hear the intern Bob telling another teammate about the differences between
        abstract classes and interfaces. He's *mostly* right, but he got one detail wrong.
        Which of the following is *not* true:
    explanation: |
        `C` is the only answer that's incorrect: both interfaces and abstract classes can
        force you to implement methods in the classes that use them. So in many ways, they
        are the same.

        So why use one or the other? Well, a class can implement *many* interfaces, which
        makes interfaces more attractive, especially for re-usable code. But, an abstract
        class can contain *real* methods, which can help you reduce code duplication between
        classes. They're similar, but not the same.
    features:
        multiple_choice:
            choices:
                a: Classes can implement many interfaces, but only extend one class.
                b: Abstract classes can contain concrete methods, but interfaces can't.
                c: Interfaces force the user to implement certain methods, abstract classes do not.
                d: |
                    Even though Interfaces don't use the `abstract` keyword before methods,
                    those methods act just like abstract methods in an abstract class.
            correct: c

interfaces_implementweaponinterfacecoding:
    question: |
        Finally something fun! Now you're working on creating different weapons for the 
        spaceships in our game.
    question_steps:
        - | 
          Looking at the `WeaponInterface` create a new `LaserWeapon` class that implements
          this interface. You can return anything you want from the methods. Just don't let the
          freedom go to your head.
        - Use the class to print out the weapon's range, just to see that things are working.
    step: interfaces-implement-weaponinterface
    files:
        index.php: ~
        LaserWeapon.php: ~
        WeaponInterface.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_class:
            type: php
            assertTrue: class_exists('\LaserWeapon')
            failure: Class `LaserWeapon` could not be found. Did you create it?
        check_implementing:
            type: php
            assertTrue: reflection_class('\LaserWeapon').implementsInterface('\WeaponInterface')
            failure: Class `LaserWeapon` should implement the `WeaponInterface` interface.
        look_for_method:
            type: php
            # TODO Wondering how can we get expressions from both http and php types togeather in one assertion?
            # I think we have a preblem here for now:
            #assertTrue: body() matches /get_variable('laserWeapon').getWeaponRange()/
            assertTrue: inputContains('index.php', 'getWeaponRange')
            failure: Seems you forgot to output the laser weapon range. Did you print the result of the `getWeaponRange()` method?

# Episode 4

# class-constants
classconstants_replacestringswithconstantscoding:
    question: |
        Our cool `GasPlanet` class is smart! We tell it what
        "main element" the planet is made out of (e.g. ammonia),
        and `getHexColor()` tells us the color of the planet.

        But, it's too easy to make a typo - e.g. `amonia` - when
        passing in the element.
    question_steps:
        - |
            Add 4 new constants to `GasPlanet` - one for each of
            the 4 materials. Give them descriptive names, like
            `MATERIAL_AMMONIA`.
        - |
            Ok! Replace the strings in your code with these
            constants.
    step: class-constants-replace-strings-with-constants
    files:
        index.php: ~
        GasPlanet.php: ~
        PlanetInterface.php:
            read_only: true
        PlanetRenderer.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_constant_1:
            type: php
            assertTrue: reflection_class('\GasPlanet').hasConstant('MATERIAL_AMMONIA')
            failure: Did you add a `MATERIAL_AMMONIA` constant to the `GasPlanet` class?
        check_constant_2:
            type: php
            assertTrue: reflection_class('\GasPlanet').hasConstant('MATERIAL_HYDROGEN')
            failure: Did you add a `MATERIAL_HYDROGEN` constant to the `GasPlanet` class?
        check_constant_3:
            type: php
            assertTrue: reflection_class('\GasPlanet').hasConstant('MATERIAL_HELIUM')
            failure: Did you add a `MATERIAL_HELIUM` constant to the `GasPlanet` class?
        check_constant_4:
            type: php
            assertTrue: reflection_class('\GasPlanet').hasConstant('MATERIAL_METHANE')
            failure: Did you add a `MATERIAL_METHANE` constant to the `GasPlanet` class?
        check_constant_usage_1:
            type: php
            assertTrue: |
                true
                and inputContains('GasPlanet.php', '::MATERIAL_METHANE')
                and inputContains('GasPlanet.php', '::MATERIAL_HYDROGEN')
                and inputContains('GasPlanet.php', '::MATERIAL_HELIUM')
                and inputContains('GasPlanet.php', '::MATERIAL_METHANE')
            failure: Replace all hardcoded strings with new `MATERIAL_*` constants in the `GasPlanet` class.
        check_constant_usage_2:
            type: php
            assertTrue: |
                true
                and inputContains('index.php', 'GasPlanet::MATERIAL_AMMONIA')
                and inputContains('index.php', 'GasPlanet::MATERIAL_METHANE')
            failure: Replace hardcoded strings with new `MATERIAL_AMMONIA` and `MATERIAL_METHANE` constants in the `input.php`.

classconstants_uppercaseconstantsmc:
    question: Why are constants always upper-case (e.g. `MATERIAL_AMMONIA`)?
    explanation: |
        The upper-casing of constants is just a standard, but standards
        are good to following! A constant is distinguished from a property
        by their keyword and the use of a `$`: `const PIZZA` versus `private $pizza`.
    features:
        multiple_choice:
            choices:
                a: "It's just a standard: constants don't *need* to be upper-case"
                b: The upper-case characters distinguishes them from normal properties
                c: Upper-case class constants are used so that they don't conflict with core PHP constants
                d: The upper-case characters help keep memory usage lower
            correct: a

classconstants_setconstantmc:
    question: |
        Suppose you want to change the value of a constant.
        Check out the following code:

        ```php
        class GasPlanet
        {
            const MATERIAL_AMMONIA = 'ammonia';
        }
        ```

        ```php
        <?php
        // ...

        GasPlanet::MATERIAL_AMMONIA = 'helium';
        ```

        Is this legal?
    explanation: |
        Constants can *never* be changed - that's the whole point! And
        they *must* be declared inside of the class with the `const` keyword.

        If you need a value that *changes*, then you don't need a constant,
        you need a *property*. And as you'll learn in a few minutes, properties
        can be static (like constants) or non-static (stay-tuned!).
    features:
        multiple_choice:
            choices:
                a: |
                    Yes, but it's not recommended. Constants are values that
                    are not *meant* to be modified.
                b: |
                    No, unless you removed the `const MATERIAL_AMMONIA = 'ammonia';`
                    from `GasPlanet`. Constants can only be set *once* either via
                    the `const` keyword, or by setting them from outside the class.
                c: Nope - changing constants is totally *not* allowed, ever.
                d: |
                    Yes, though it's recommended to change constants from inside
                    the class where they are declared (i.e. `GasPlanet`).
            correct: c

classconstants_hexcolorconstantsmc:
    question: |
        The intern has gone *crazy* with constants, by even making the
        hex strings into constants:

        ```php
        class GasPlanet implements PlanetInterface
        {
            // ...

            const COLOR_BROWN_ISH = '663300';
            const COLOR_BLUE_BRIGHT = '0066FF';
            const COLOR_GRAY_DARK = '464646';
            // ...

            public function getHexColor()
            {
                // a "fake" map of elements to colors
                switch ($this->mainElement) {
                    case GasPlanet::MATERIAL_AMMONIA:
                        return GasPlanet::COLOR_BROWN_ISH;
                    case GasPlanet::MATERIAL_METHANE:
                        return GasPlanet::COLOR_BLUE_BRIGHT;
                    default:
                        return GasPlanet::COLOR_GRAY_DARK;
                }
            }
        }
        ```

        Is this a good step forward?
    explanation: |
        Not *all* strings or numbers should be turned into constants.
        If you're thinking about making something a constant, ask yourself:

        * Are these strings used multiple times?
        * Are these strings used from *outside* of the class?
        * If someone makes a minor typo, will the result be drastically different?
        * Is it important for us to have a list of all of these possible values in one spot.

        In this case, the answer is no to *all* of these questions. For
        example, if we typo `ammonia` as `amonia`, the planet would have
        a drastically different color. But if we typo `663300` as `663301`,
        that won't make much difference, because the hex values are not
        being used as *exact keys* to decide how the code behaves.
    features:
        multiple_choice:
            choices:
                a: |
                    Not really. These hex colors aren't used outside of this
                    class ever (or even multiple times *inside* of this class),
                    so there's no advantage to making these constants.
                b: "Absolutely: it's important to make all static strings into constants."
                c: "No: the hex colors shouldn't be constants, in case we need to change them later."
            correct: a

# static-vs-non-static-and-self
staticvsnonstaticandself_staticpropertymc:
    question: |
        The intern is *loving* the idea of static properties, but I feel
        like he's a little confused. But, he's got a good spirit! Let's
        check out his code and offer him some advice:

        ```php
        class SolidPlanet
        {
            private $radius;

            private static $hexColor;

            private $hasBeenVisitedByAliens;

            private $numberOfHabitablePlanetsInUniverse;
        }
        ```

        Which of the following are true:
    explanation: |
        When determining static or non-static, ask yourself this question:

        > Does *each* individual planet have its own value for this
        > property? Or is there just one value for *all* planets?

        Looking at each property, here's how it looks:

        * `radius`: Each planet has a different radius: *not static*
        * `hexColor`: Each planet also has its own color: *non static*
        * `hasBeenVisitedByAliens`: Some planets may have been visited by aliens
          and others not: *non static*
        * `$numberOfHabitablePlanetsInUniverse`: This is a global number,
          it applies to *all* planets: it's not a property of just one
          planet: *static*

        When in doubt, use non-static!
    features:
        multiple_choice:
            choices:
                a: The `$hexColor` property should *not* be static
                b: The `$radius` property should be static
                c: The `$numberOfHabitablePlanetsInUniverse` should be static
                d: Both (A) and (C) are true!
                e: Both (B) and (C) are true!
            correct: d

staticvsnonstaticandself_useselfkeywordcoding:
    question: |
        We're doing to much work by using the whole class name `GasPlanet`!
    question_steps:
        - Refactor `GasPlanet` to use `self` to reference the constants.
    step: static-vs-non-static-and-self-replace-class-name-with-self
    files:
        GasPlanet.php: ~
        index.php:
            read_only: true
        PlanetInterface.php:
            read_only: true
        PlanetRenderer.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_constant_usage:
            type: php
            assertTrue: |
                true
                and inputContains('GasPlanet.php', 'self::MATERIAL_METHANE')
                and inputContains('GasPlanet.php', 'self::MATERIAL_HYDROGEN')
                and inputContains('GasPlanet.php', 'self::MATERIAL_HELIUM')
                and inputContains('GasPlanet.php', 'self::MATERIAL_METHANE')
            failure: Replace all `GasPlanet::MATERIAL_*` with `self::MATERIAL_*` in the `GasPlanet` class.

# static-methods
staticmethods_staticgetallelementscoding:
    question: |
        The gas planets are kind of pretty, so we want to render
        *all* of them for the user to enjoy. Simple! By creating
        one `GasPlanet` object for each possible element, we've
        done it!

        But, you know the problem: if we add *more* elements to
        `GasPlanet`, we'll need to remember to come here and create
        another object. Lame!
    question_steps:
        - |
            Create a new *static* method called `getAllElements()`
            that returns the 4 possible gas planet elements.
        - |
            Call this from `index.php` and use a `foreach` to
            render the 4 different gas planets.
    step: static-methods-get-all-elements
    files:
        GasPlanet.php: ~
        index.php: ~
        PlanetInterface.php:
            read_only: true
        PlanetRenderer.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        search_for_method:
            type: php
            assertTrue: reflection_class('\GasPlanet').hasMethod('getAllElements')
            failure: Did you add `getAllElements()` method in the `GasPlanet.php` class?
        assert_method_is_static:
            type: php
            assertTrue: reflection_class('\GasPlanet').getMethod('getAllElements').isStatic()
            failure: Did you make the `getAllElements()` method static?
        search_for_method_call:
            type: php
            assertTrue: inputContains('index.php', 'GasPlanet::getAllElements()')
            failure: Did you iterate over `GasPlanet::getAllElements()` static method in the `index.php`?
        search_for_foreach:
            type: php
            assertTrue: inputContains('index.php', 'foreach')
            failure: Did you iterate all elements with a `foreach` loop in the `index.php`?
        search_for_new_object:
            type: php
            assertTrue: inputContains('index.php', 'new GasPlanet')
            failure: Did you create a `new GasPlanet` object in the `foreach` loop?

staticmethods_fixerrorscoding:
    question: |
        You take *one* day for a holiday, and the intern experimented
        in the code and broke things! Now that you're back, well-rested
        and with a nice tan, see if you can get the code working again.
    question_steps:
        - Render the page to see what the error is
        - Find the bug and squash it!
    explanation: |
        When deciding between making a method static or non-static,
        one easy question to ask is:

        > Does this method need to use the `$this` variable?

        If it *does*, then it should *not* be static. Simple!
    step: static-methods-create-randomlycoloredplanet-class
    files:
        RandomlyColoredPlanet.php: ~
        index.php:
            read_only: true
        PlanetInterface.php:
            read_only: true
        PlanetRenderer.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        assert_method_is_not_static:
            type: php
            assertFalse: reflection_class('\RandomlyColoredPlanet').getMethod('getRandomColor').isStatic()
            failure: You should make the `getRandomColor()` method **not** static.
        check_method_call_with_this:
            type: php
            assertFalse: inputContains('RandomlyColoredPlanet.php', 'self::getRandomColor')
            failure: You can call non-static `getRandomColor()` method with `self::`, but let's use `$this->` instead.
        check_argument_name:
            type: php
            assertTrue: inputContains('RandomlyColoredPlanet.php', '__construct($color1, $color2)')
            failure: There's one more typo with the second argument name in the constructor. Did you see it?

staticmethods_staticvsnonstaticmc:
    question: |
        We're building a new class of planets that *always* have the
        same radius. We're in a heated (geeky) debate over whether or
        not to make a method static. Here are the two options:

        ```php
        // OPTION 1
        class StaticallySizedPlanet
        {
            public function getRadius()
            {
                return 250;
            }
        }
        ```

        ```php
        // OPTION 2
        class StaticallySizedPlanet
        {
            public static function getRadius()
            {
                return 250;
            }
        }
        ```

        Which would you recommend?
    explanation: |
        This one is tough :).

        Deciding whether or not to make a method static has *nothing*
        to do with whether or not that method will return a "static"
        (or constant value). And just because you *don't* need the
        `$this` keyword does *not* automatically mean that you should
        make something static (though the opposite *is* true: if you
        need `$this`, make it non-static).

        Instead, you need to ask yourself:

        > When I call this method, am I calling this method on one
        > individual "planet" object or on the StaticallySizedPlanet
        > class in general?

        In those case, both sound pretty reasonable: so both static
        and non-static are *good* answers. However, if you're ever
        not sure - or both options make sense - choose non-static.
        Put simply: this will give you more flexibility in the future.
    features:
        multiple_choice:
            choices:
                a: |
                    OPTION 1 (non-static): The "radius" of a planet is a
                    property that should really belong to each, individual planet.
                b: |
                    OPTION 1 (non-static): "getter" functions like this
                    (e.g. `getRadius()`, `getName()`, etc) should always be non-static.
                c: |
                    OPTION 2 (static): The method does not rely on the
                    `$this` variable, so we should make it static.
                d: |
                    OPTION 2 (static): The method always returns a static,
                    or constant value. This is precisely when you should use
                    a static method.
            correct: a

# namespaces-make-class-names-longer
namespacesmakeclassnameslonger_addnamespacecoding:
    question: |
        Since we *love* long class names, so we're going to start giving
        our classes namespaces?

        (But seriously, I'll show you why namespaces are *actually* awesome soon).
    question_steps:
        - Give `RandomlyColoredPlanet` a namespace of `Model\Planet`
        - |
          **Without** using a `use` statement, update `index.php` so
          that everything still works.
    step: namespaces-make-class-names-longer-add-namespace
    files:
        index.php: ~
        RandomlyColoredPlanet.php: ~
        PlanetInterface.php:
            read_only: true
        PlanetRenderer.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        assert_namespace:
            type: php
            assertTrue: class_exists('Model\\Planet\\RandomlyColoredPlanet')
            failure: You should add `Model\Planet` namespace for the `RandomlyColoredPlanet` class.
        check_fqcn_usage:
            type: php
            assertTrue: inputContains('index.php', 'Model\\Planet\\RandomlyColoredPlanet')
            failure: Did you use the fully qualified class name `Model\Planet\RandomlyColoredPlanet` in the `index.php`?
        search_for_use:
            type: php
            assertFalse: inputContains('index.php', 'use ')
            failure: You shouldn't add a `use` statement to complete this challenge.

namespacesmakeclassnameslonger_usenamespacecoding:
    question: |
        Even though we don't *need* to use `use` statements, we almost
        always do.
    question_steps:
        - Update `index.php` to use a `use` statement for the `RandomlyColoredPlanet` class.
    step: namespaces-make-class-names-longer-add-use-statement
    files:
        index.php: ~
        RandomlyColoredPlanet.php:
            read_only: true
        PlanetInterface.php:
            read_only: true
        PlanetRenderer.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        search_for_use_with_slash:
            type: php
            assertFalse: inputContains('index.php', 'use \\Model\\Planet\\RandomlyColoredPlanet;')
            failure: You don't have to use a start slash `\` when use a namespace. Let's remove it!
        search_for_use_without_slash:
            type: php
            assertTrue: inputContains('index.php', 'use Model\\Planet\\RandomlyColoredPlanet;')
            failure: You should add a `use` statement for `RandomlyColoredPlanet` class namespace.
        search_for_use:
            type: php
            assertTrue: inputContains('index.php', 'new RandomlyColoredPlanet')
            failure: You don't have to use a full namespace when add it with a use statement - just use `new RandomlyColoredPlanet`.

namespacesmakeclassnameslonger_useonemorenamespacecoding:
    question: |
        Since you're feeling pretty comfortable with namespaces, you
        decide to delegate the rest of the work to the intern. Nice
        management move!

        But, when you get the code back, things aren't *quite* right.
    question_steps:
        - Load the page to see the error
        - Find the problem and fix it!
    step: namespaces-make-class-names-longer-add-namespace-to-the-planetrenderer
    files:
        index.php: ~
        RandomlyColoredPlanet.php:
            read_only: true
        PlanetInterface.php:
            read_only: true
        PlanetRenderer.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        search_for_use_with_slash:
            type: php
            assertFalse: inputContains('index.php', 'use \\Service\\PlanetRenderer;')
            failure: You don't have to use a start slash `\` when use a namespace. Let's remove it!
        search_for_use_without_slash:
            type: php
            assertTrue: inputContains('index.php', 'use Service\\PlanetRenderer;')
            failure: You should add a `use` statement for `PlanetRenderer` class namespace.
        search_for_use:
            type: php
            assertTrue: inputContains('index.php', 'new PlanetRenderer')
            failure: You don't have to use a full namespace when add it with a use statement - just use `new PlanetRenderer`.

namespacesmakeclassnameslonger_namespaceusagemc:
    question: |
        Look at the following class:

        ```php
        namespace Model\Planet.

        class RandomlyColoredPlanet
        {
            // ...
        }
        ```

        Which of the following is *not* a valid way to reference
        this class from inside `index.php`:
    explanation: |
        Trick question! Well, sort of :).

        One of the most common errors with `use` statements is
        to forget that you need to include the namespace *and* the
        class name:

        ```php
        use Model\Planet; // wrong
        use Model\Planet\RandomlyColoredPlanet; // correct!

        new RandomlyColoredPlanet();
        ```

        This is because PHP sees `RandomlyColoredPlanet` and looks
        for a `use` statement that *ends* with this string.

        If you *do* forget the last part of the `use` statement
        (e.g. `use Model\Planet`), you can technically get your
        code to work by saying `new Planet\RandomlyColoredPlanet()`.
        This is pretty rare to see in the wild.
    features:
        multiple_choice:
            choices:
                a: |
                    ```php
                    new Model\Planet\RandomlyColoredPlanet();
                    ```
                b: |
                    ```php
                    use Model\Planet;

                    new RandomlyColoredPlanet();
                    ```
                c: |
                    ```php
                    use Model\Planet;

                    new Planet\RandomlyColoredPlanet();
                    ```
                d: All of these are correct!
            correct: b

# autoloading-awesomeness
autoloadingawesomeness_addautoloadercoding:
    question: |
        These `require` statements are *really* starting to cramp
        my style! Start simple:
    question_steps:
        - Remove the `require` statement for `RandomlyColoredPlanet.php`.
        - Add an autoloader function (`spl_autoload_register`) at the top of `index.php`.
        - Inside that function, if the class equals `RandomlyColoredPlanet`, require that file.
        - Refresh to see everything working *without* the `require` statement!
    step: autoloading-awesomeness-add-simple-autoloader
    files:
        index.php: ~
        RandomlyColoredPlanet.php:
            read_only: true
        PlanetInterface.php:
            read_only: true
        PlanetRenderer.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        search_for_function:
            type: php
            assertTrue: inputContains('index.php', 'spl_autoload_register')
            failure: You should register your autoloader function with the `spl_autoload_register`.
        search_for_if:
            type: php
            assertTrue: inputContains('index.php', 'if')
            failure: You should require file only if a class name is equal to `Model\Planet\RandomlyColoredPlanet`.
        search_for_file:
            type: php
            assertTrue: inputContains('index.php', 'RandomlyColoredPlanet.php')
            failure: You should require the `RandomlyColoredPlanet.php` file inside a registered autoloader function.

autoloadingawesomeness_betterperformancemc:
    question: |
        Ultimately - whether via a manual `require` statement written
        by you or via an autoloader function - *something* needs to
        require/include a file before we can use the class that lives
        inside of it.

        But, which option will give you better performance?
    explanation: |
        Not only are autoloaders going to make your life simpler, they're
        *faster* than manually writing require statements. Well, most of
        the time :).

        The big reason is that - with an autoload function - you only
        include a file *if* you actually need it during a request. If
        you never reference a class, then you never include its file
        and never incur the added overhead of loading this class into
        memory. Yay!

        But to make this a reality, the *logic* inside of your autoloaders
        needs to be fast! If your logic searches various files to look
        for a class each time the autoloader is called, that will be *way*
        slow!

        That's why the autoloader we built in teh tutorial takes advantage
        of a class's namespace to quickly locate it!
    features:
        multiple_choice:
            choices:
                a: Autoloaders are *always* faster than manually having many require statements.
                b: |
                    Autoloaders are *usually* faster than having require
                    statements, because you don't need to include files that
                    you don't use.
                c: |
                    Manual require statements are *always* faster than autoloaders.
                    Yes, they're annoying to write, but there is a lot of extra
                    overhead for calling the autoload function over and over again.
                d: |
                    Manual require statements are *always* faster than an
                    autoloader function. By requiring all of the files in the
                    very beginning, your application can quickly reference any
                    class or function it needs.
            correct: b

# more-with-use-statements
morewithusestatements_usesmartautoloadercoding:
    question: |
        Time to remove *all* of the `require` statements! YES!

        We made the intern work late last night, and he got us off
        to a nice start: the classes now live in different directories
        *and* our `spl_autoload_register` function is smart!
    question_steps:
        - Remove all of the require statements
        - Give each class a proper namespace so that the autoload function can find them!
        - Fix anything else needed in the code after giving the classes namespaces
    step: more-with-use-statements-use-smart-autoloader
    files:
        index.php: ~
        src/Model/Planet/PlanetInterface.php: ~
        src/Model/Planet/GasPlanet.php: ~
        src/Model/Planet/SolidPlanet.php: ~
        src/Model/Planet/RandomlyColoredPlanet.php: ~
        src/Service/PlanetRenderer.php: ~
    features:
        editor: ~
        browser: ~
    grading:
        search_for_require:
            type: php
            assertFalse: |
                false
                or inputContains('index.php', 'PlanetRenderer.php')
                or inputContains('index.php', 'GasPlanet.php')
                or inputContains('index.php', 'SolidPlanet.php')
                or inputContains('index.php', 'RandomlyColoredPlanet.php')
            failure: You should remove all of the `require` statements in `index.php` except one in the `spl_autoload_register`.
        assert_namespace:
            type: php
            assertTrue: |
                true
                and class_exists('\\Service\\PlanetRenderer')
                and class_exists('\\Model\\Planet\\GasPlanet')
                and class_exists('\\Model\\Planet\\SolidPlanet')
                and class_exists('\\Model\\Planet\\RandomlyColoredPlanet')
            failure: A namespace of all classes should match the directory structure.

morewithusestatements_fixnamespacecoding:
    question: |
        We *thought* we were done converting everything to have a
        namespace, but now we're stuck on this error!
    question_steps:
        - Reload the page to see the error
        - Find the bug and squash it!
    step: more-with-use-statements-fix-invalid-namespace
    files:
        src/Model/Planet/GasPlanet.php: ~
        index.php:
            read_only: true
        src/Model/Planet/SolidPlanet.php:
            read_only: true
        src/Model/Planet/RandomlyColoredPlanet.php:
            read_only: true
        src/Service/PlanetRenderer.php:
            read_only: true
        src/Model/Planet/PlanetInterface.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        assert_namespace:
            type: php
            assertTrue: class_exists('\\Model\\Planet\\GasPlanet')
            failure: A namespace of the `GasPlanet` class should match the directory structure.

# namespaces-core-php-classes
namespacescorephpclasses_addplanetdaylengthcoding:
    question: |
        The length of a day on Earth is 24 hours, but other planets have
        *drastically* different day lengths! No problem! We've already
        added a new property to `SolidPlanet` - `dayLengthInHours` - to
        help control this.

        Now, we want to be able to print *when* one day from now will
        be for a specific planet.
    question_steps:
        - Add a new method to `SolidPlanet` called `getDateTimeOneDayFromNow()`.
        - |
            Inside, create a new `DateTime` object and add X hours to it,
            where X is the value of the `dayLengthInHours` property. You can
            use the commented-out `DateTime` code in `index.php` as a guide!
        - |
            In `index.php`, call the new `getDateTimeOneDayFromNow()` method
            and set it to a variable called `$tomorrow` so that it will be
            rendered in the `h3` tag.
    step: namespaces-core-php-classes-use-planet-day-length
    files:
        index.php: ~
        src/Model/Planet/SolidPlanet.php: ~
        src/Service/PlanetRenderer.php:
            read_only: true
        src/Model/Planet/PlanetInterface.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        search_for_method:
            type: php
            assertTrue: reflection_class('\\Model\\Planet\\SolidPlanet').hasMethod('getDateTimeOneDayFromNow')
            failure: You should add a `getDateTimeOneDayFromNow()` method to the `SolidPlanet`.
        assert_datetime:
            type: php
            assertTrue: get_class(variable('planet').getDateTimeOneDayFromNow()) === 'DateTime'
            failure: You should return a `DateTime` object in the `getDateTimeOneDayFromNow()` method.
        search_for_method_usage:
            type: php
            assertTrue: inputContains('index.php', '->getDateTimeOneDayFromNow()')
            failure: Did you use the `getDateTimeOneDayFromNow()` method in the `index.php`?

namespacescorephpclasses_datetimemc:
    question: |
        Which of the following pieces of code would **not** work:
    explanation: |
        The best code is probably (A): `new \DateTime()`. This
        wil *always* work, whether you're in a file with a namespace
        or not.

        If you simply say `new DateTime()`, this only *might* work.
        If you're in a file whose namespace is `Foo`, then PHP thinks
        you're referring to a class called `Foo\DateTime` (wrong!).
        That's why adding the `\` in front is always best.

        The final answer - with the `use DateTime` - looks a little
        funky, but is also technically valid. A `use` statement always
        anchors from the *root* of the namespace. In other words, even
        though we type `use DateTime`, it means `use \DateTime`. So yes,
        you actually *can* use `use` statements with core PHP classes.
    features:
        multiple_choice:
            choices:
                a: |
                    ```php
                    namespace Foo;

                    new \DateTime();
                    ```
                b: |
                    ```php
                    // not in a namespaced file

                    new DateTime();
                    ```
                c: |
                    ```php
                    namespace Foo;

                    new DateTime();
                    ```
                d: |
                    ```php
                    namespace Foo;

                    use DateTime;

                    new DateTime();
                    ```
                e: These would all work!
            correct: c

# composer-autoloading

# throw-exceptions

# exception-classes

# magic-methods

# array-access
arrayaccess_implementingarrayaccesscoding:
    question: |
        Our app *also* deals with meteoroids: those cute
        little flying rocks that occasionally threaten
        life itself on Earth. Yay!

        Since a meteoroid is just a chunk of different metals,
        we've given it an `elements` property to hold whatever
        metals it has. Let's print these... by treating this
        class like an array!
    question_steps:
        - |
            Implement the `ArrayAccess` interface and add the
            4 methods you need to your class (sorry, PhpStorm can't
            help you this one time!)
        - |
            Fill in the logic for each method so that we can
            access the `$elements` property like an array.
        - |
            In `metor.php`, print the `Iron`, `Nickel` and `Cobalt`
            masses in the correct table boxes.
    step: arrayaccess-implement-arrayaccess
    files:
        metor.php: ~
        Meteoroid.php: ~
    features:
        editor: ~
        browser:
            default_uri: metor.php
    grading:
        assert_implementing:
            type: php
            assertTrue: reflection_class('\Meteoroid').implementsInterface('\ArrayAccess')
            failure: Class `Meteoroid` should implement the `ArrayAccess` interface.
        search_for_array_call:
            type: php
            assertTrue: inputContains('metor.php', '$meteoroid[')
            failure: Did you call `$meteoroid` variable as array to print each element mass in the table?

arrayaccess_arrayorobjectmc:
    question: |
        Challenge! Check out the following code:

        ```php
        // some code that you can't see!

        echo $planet['radius']; // prints 50

        echo $planet['atmosphere']->getMainElement(); // prints Nitrogen

        echo $blackhole; // prints an empty string

        $solarSystem[] = $planet;
        ```

        Which of the following is **not** true:
    explanation: |
        Things are never as simple as they seem!

        A) `$planet` is used like an array, but we know that this
        could be because it's an array *or* an object that
        implements `ArrayAccess`.

        B) `$solarSystem` is *also* used like an array with the
        `$solarSystem[] = $planet;` syntax. So this might *also*
        be an object!

        C) If `$blackHole` is an object that has a `__toString()`
        method, then we could of course print this.

        D) Because of the code `$planet['atmosphere']->getMainElement();`,
        we know that `$planet['atmosphere']` must be an object. You
        can *only* call a method on an object.
    features:
        multiple_choice:
            choices:
                a: "`$planet` could be an array *or* an object"
                b: "`$solarSystem` is definitely an array"
                c: "`$blackHole` could be a string or an object"
                d: "`$planet['atmosphere']` is definitely an object"
            correct: b

# iterator-aggregate

# traits-reuse

# composition-ftw
