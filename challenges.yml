# Extending
extending_inheritfunctionalitycoding:
    question: >
        Your team has been working hard building the `DeathStar` class, only
        to find out that the Rebels have just destroyed it! Time to rebuild!
        Create a new class called `DeathStarII` in the `DeathStarII.php` file
        and make it inherit all of the functionality from the original `DeathStar`.
        In `index.php`, instantiate a new `DeathStarII` object and set it to
        a `$deathStar` variable. Long live the Empire!
    step: ~
    files:
        index.php: ~
        DeathStarII.php: ~
        DeathStar.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_variable:
            type: php
            # TODO: Implement variable_exists() function
            assertTrue: variable_exists('deathStar')
            failure: Make sure the `$deathStar` variable is exist
        assert_instance_of_1:
            type: php
            # @TODO: Implement is_subclass_of() and get_variable() functions
            assertTrue: is_subclass_of(get_variable('deathStar'), '\DeathStarII')
            failure: The `$deathStar` variable exists, but is not set to a `DeathStarII` object.
        assert_instance_of_2:
            type: php
            assertTrue: is_subclass_of(get_variable('deathStar'), '\DeathStar')
            failure: The `DeathStarII` class is not extending `DeathStar` one.

extending_callnonexistentmethodmc:
    question: >
        Look at these two classes:

        ```php
        class Ship
        {
            public function getName()
            {
                return 'Starfighter';
            }
        }
        ```

        ```php
        class JediShip extends Ship
        {
            public function getFavoriteJedi()
            {
                return 'Yoda';
            }
        }
        ```

        Suppose we instantiate both objects:

        ```php
        $ship = new Ship();
        $jediShip = new JediShip();
        ```

        Which of the following lines will cause an error?
    explanation: >
        The `Ship` object does *not* have a `getFavoriteJedi()` method
        on it - only `JediShip` has this. But, since `JediShip extends Ship`,
        the `JediShip` *does* have a `getName()` method: it inherits it from
        `Ship`.
    features:
        multiple_choice:
            choices:
                a: `echo $ship->getName();`
                b: `echo $ship->getFavoriteJedi();`
                c: `echo $jediShip->getName();`
                d: Both (B) and (C) will cause an error
            correct: b

# Override
override_overrideinheritmethodcoding:
    question: >
        Well, we learned some hard lessons after the destruction of the original `DeathStar`,
        and we don't want to repeat them! Override the `getWeakness()` method in `DeathStarII`
        and make it return `null`. Phew, problem solved!
    step: ~
    files:
        DeathStarII.php: ~
        index.php:
            read_only: true
        DeathStar.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_variable_1:
            type: php
            assertTrue: variable_exists('original')
            failure: Make sure the `$original` variable is exist
        check_variable_2:
            type: php
            assertTrue: variable_exists('new')
            failure: Make sure the `$new` variable is exist
        assert_instance_of_1:
            type: php
            assertTrue: is_subclass_of(get_variable('original'), '\DeathStar')
            failure: The `$original` variable exists, but is not set to a `DeathStar` object.
        assert_instance_of_2:
            type: php
            assertTrue: is_subclass_of(get_variable('new'), '\DeathStarII')
            failure: The `$new` variable exists, but is not set to a `DeathStarII` object.
        assert_instance_of_3:
            type: php
            assertTrue: is_subclass_of(get_variable('new'), '\DeathStar')
            failure: The `DeathStarII` class is not extending `DeathStar` one.
        assert_method_1:
            type: php
            assertTrue: 'Thermal Exhaust Port' === get_variable('original').getWeakness()
            failure: The return value of `getWeakness()` method in a `DeathStar` class was changed. You should override it.
        assert_method_2:
            type: php
            assertTrue: null !== get_variable('new').getWeakness()
            failure: The `getWeakness()` method of `DeathStarII` class does not return `null`.

override_calloverriddenmethodmc:
    question: >
        Look at the following classes:

        ```php
        class Ship
        {
            public function printType()
            {
                echo 'Empire Ship';

                $this->printMotto();
            }

            public function printMotto()
            {
                echo 'I like to fly!';
            }
        }
        ```

        ```php
        class RebelShip extends Ship
        {
            public function printType()
            {
                echo 'Rebel Ship';
            }
        }
        ```

        What is the result of the following code:

        ```
        $ship = new Ship();
        $rebelShip = new RebelShip();
        $ship->printType();
        $rebelShip->printType();
        ```
    explanation: >
        For `Ship`, `printType()` prints "Empire Ship" and then also
        calls `printMotto()`. But for `RebelShip`, `printType()` only
        prints "Rebel Ship". *Nothing* calls the `printMotto()`
        function in this case.
    features:
        multiple_choice:
            choices:
                a: `Empire ShipRebelShip`
                b: `Empire ShipI like to fly!RebelShip`
                c: `Empire ShipI like to fly!RebelShipI like to fly`
                d: `RebelShipRebelShip`
            correct: b

# ProtectedVisibility
protectedvisibility_getinheritedpropertycoding:
    question: >
        The construction of the `DeathStarII` continues, but we need access
        to the `planetarySuperLaserRange` property from the original, because
        we're going to make it fire twice as far! Fix the `DeathStar` class
        so that the new `getSpecs()` method works:
    step: ~
    files:
        DeathStar.php: ~
        DeathStarII.php:
            read_only: true
        index.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_property:
            type: php
            assertTrue: reflection_class('\DeathStar').hasProperty('planetarySuperLaserRange')
            failure: The `planetarySuperLaserRange` property does not exist in the `DeathStar` class.
        check_property_visibility:
            type: php
            assertTrue: reflection_class('\DeathStar').getProperty('planetarySuperLaserRange').isProtected()
            failure: The `planetarySuperLaserRange` property should have protected visibility.

protectedvisibility_propertyvisibilitymc:
    question: >
        Check out the following code:

        ```php
        // Ship.php

        class Ship
        {
            public $name;

            protected $weaponPower;

            private $defense;

            public function getDefense()
            {
                return $this->defense;
            }
        }
        ```

        ```php
        // JediShip.php

        class JediShip extends Ship
        {
            public function getWeaponPower()
            {
                return $this->weaponPower;
            }
        }
        ```

        ```php
        // index.php

        $jediShip = new JediShip();
        $jediShip->name;
        $jediShip->weaponPower;
        ```

        Which of the above code will give us an error?
    explanation: >
        Since the `$defense` property is `private`, we can only access it from
        within the `Ship` class. But that's exactly what we're doing in (B),
        so that's fine.

        The `$weaponPower` property is `protected`. That means we can access it
        only from inside `Ship`, `JediShip` or any other sub-classes. That's why
        (C) is valid. But in (A), we're accessing `weaponPower` from `index.php`.
        Accessing a property or method from outside of the class is only allowed
        if it is public. This is a bad code.
    features:
        multiple_choice:
            choices:
                a: `$jediShip->weaponPower` in `index.php`
                b: `return $this->defense` in `Ship.php`
                c: `return $this->weaponPower` in `JediShip.php`
                d: None of the above is bad code - we're awesome!
            correct: a

# Parent
parent_callparentmethodcoding:
    question: >
        It took too long to travel to planets to destroy them
        in the first DeathStar, so Darth wants the laser range
        on the new DeathStar to be *twice* as far! Override
        the `getLaserRange()` method in `DeathStarII` to make
        this happen. But don't repeat the `2000000` value!
        Call the parent function and then multiple that value by 2!
    step: ~
    files:
        DeathStarII.php: ~
        DeathStar.php:
            read_only: true
        index.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_method:
            type: php
            assertTrue: method_exists(get_variable('deathStar'), 'getLaserRange')
            failure: The `getLaserRange()` method does not exist for the `DeathStarII` class - did you create it?
        assert_method:
            type: php
            assertTrue: 4000000 === get_variable('deathStar').getLaserRange()
            failure: The `getLaserRange()` method in the `DeathStarII` class should return a doubled value of the parent method.

# AbstractShip
abstractship_extendabstractclasscoding:
    question: >
        We've just gotten word that the Rebels have *also*
        destroyed the `DeathStarII`. Wow, rotten luck. Anyways,
        it sounds like we'll be creating blue prints for many
        different types of DeathStar's in the future, to keep
        the Rebels guessing.

        To make this easier, create an `AbstractDeathStar` class,
        move all of the shared code into it, and update
        `DeathStar` and `DeathStarII` to extend this new class.
        Make sure to get rid of anything in those classes
        that you've moved into the new parent class.
    step: ~
    files:
        AbstractDeathStar.php: ~
        DeathStar.php: ~
        DeathStarII.php: ~
        index.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_class:
            type: php
            assertTrue: class_exists('\AbstractDeathStar')
            failure: The `AbstractDeathStar` class does not exist! Did you create it?
        assert_abstract:
            type: php
            assertTrue: reflection_class('\AbstractDeathStar').isAbstract()
            failure: The `AbstractDeathStar` class should be declared as abstract.
        check_methods:
            type: php
            assertTrue: reflection_class('\AbstractDeathStar').hasMethod('setWeaponPower') and reflection_class('\AbstractDeathStar').hasMethod('getWeaponPower') and reflection_class('\AbstractDeathStar').hasMethod('makeFiringNoise')
            failure: The `AbstractDeathStar` class should have `getWeaponPower()`, `setWeaponPower()`, and `makeFiringNoise()` methods.
        check_method:
            type: php
            assertTrue: reflection_class('\AbstractDeathStar').hasMethod('setCrewSize')
            failure: The `AbstractDeathStar` class should not have a `setCrewSize()` method! The `DeathStarII` just has a hardcoded crew size, so does not need this setter. Move it to `Deathstar`.
        assert_subclass_of:
            type: php
            assertTrue: reflection_class('\DeathStar').isSubclassOf('\AbstractDeathStar') and reflection_class('\DeathStarII').isSubclassOf('\AbstractDeathStar')
            failure: The both `DeathStar` and `DeathStarII` classes should extend `AbstractDeathStar` one.

abstractship_inheritanceoverheadmc:
    question: >
        A co-worker created a few classes and has asked for
        your advice about organizing them:

        ```php
        class Ship
        {
            private $name;

            public function getName()
            {
                return $name;
            }

            public function setName($name)
            {
                $this->name = $name;
            }

            // other stuff...
        }
        ```

        ```php
        class Person
        {
            private $name;

            public function getName()
            {
                return $name;
            }

            public function setName($name)
            {
                $this->name = $name;
            }

            // other stuff...
        }
        ```

        Your teammate is wondering if this can be organized better.
        Which if the following is the best advice?
    explanation: >
        Even though both classes share some code, a `Ship`
        and a `Person` fundamentally aren't the same thing,
        and probably don't have any other overlapping code.
        So, you *could* create an `AbstractNamedItem`, but
        that's a bit awkward. And remember, you can only
        extend *one* class, so make sure your parent class
        makes sense.

        In this case, the best action is to do nothing: leave
        these two blueprints totally independent. In a future
        episode, we'll talk about traits: a cool way to help
        remove duplication without inheritance.
    features:
        multiple_choice:
            choices:
                a: >
                    Create a new `AbstractNamedItem` class that has the
                    `name` property and the `getName()` and `setName()`
                    methods. Then, make `Person` and `Ship` extend this
                    class.
                b: >
                    Make `Ship` extend `Person`, and remove all the
                    duplicated code in `Person`.
                c: >
                    Leave things exactly like they are now.
            correct: c

# BrokenShip
brokenship_createdeathstariiicoding:
    question: >
        I feel like we're *always* designing new DeathStars. Well, time to start
        the DeathStarIII! Create a new `DeathStarIII` class, make it extend
        `AbstractDeathStar`, and fill in any missing abstract methods. Finally,
        print out the description in `index.php`.
    step: ~
    files:
        DeathStarIII.php: ~
        index.php: ~
        AbstractDeathStar.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        assert_subclass_of:
            type: php
            assertTrue: reflection_class('\DeathStarIII').isSubclassOf('\AbstractDeathStar')
            failure: The `DeathStarIII` class should extend the `AbstractDeathStar` one.
        check_class:
            type: php
            assertTrue: css('h3') matches get_variable('deathStar3').getDescription()
            failure: Hmm, did you print the `DeathStarIII` description in `h3` tag?
