# Extending
extending_inheritfunctionalitycoding:
    question: >
        Your team has been working hard building the `DeathStar` class, only
        to find out that the Rebels have just destroyed it! Time to rebuild!
        Create a new class called `DeathStarII` in the `DeathStarII.php` file
        and make it inherit all of the functionality from the original `DeathStar`.
        In `index.php`, instantiate a new `DeathStarII` object and set it to
        a `$deathStar` variable. Long live the Empire!
    step: ~
    files:
        index.php: ~
        DeathStarII.php: ~
        DeathStar.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_variable_existent:
            type: php
            # TODO: Implement variable_exists() function
            assertTrue: variable_exists('deathStar')
            failure: Make sure the `$deathStar` variable is exist
        assert_instance_of_1:
            type: php
            # @TODO: Implement is_subclass_of() and get_variable() functions
            assertTrue: is_subclass_of(get_variable('deathStar'), '\DeathStarII')
            failure: The `$deathStar` variable exists, but is not set to a `DeathStarII` object.
        assert_instance_of_2:
            type: php
            assertTrue: is_subclass_of(get_variable('deathStar'), '\DeathStar')
            failure: The `DeathStarII` class is not extending `DeathStar` one.

extending_callnonexistentmethodmc:
    question: >
        Look at these two classes:

        ```php
        class Ship
        {
            public function getName()
            {
                return 'Starfighter';
            }
        }
        ```

        ```php
        class JediShip extends Ship
        {
            public function getFavoriteJedi()
            {
                return 'Yoda';
            }
        }
        ```

        Suppose we instantiate both objects:

        ```php
        $ship = new Ship();
        $jediShip = new JediShip();
        ```

        Which of the following lines will cause an error?
    explanation: >
        The `Ship` object does *not* have a `getFavoriteJedi()` method
        on it - only `JediShip` has this. But, since `JediShip extends Ship`,
        the `JediShip` *does* have a `getName()` method: it inherits it from
        `Ship`.
    features:
        multiple_choice:
            choices:
                a: `echo $ship->getName();`
                b: `echo $ship->getFavoriteJedi();`
                c: `echo $jediShip->getName();`
                d: Both (B) and (C) will cause an error
            correct: b

# Override
override_overrideinheritmethodcoding:
    question: >
        Well, we learned some hard lessons after the destruction of the original `DeathStar`,
        and we don't want to repeat them! Override the `getWeakness()` method in `DeathStarII`
        and make it return `null`. Phew, problem solved!
    step: ~
    files:
        DeathStarII.php: ~
        index.php:
            read_only: true
        DeathStar.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_variable_existent_1:
            type: php
            assertTrue: variable_exists('original')
            failure: Make sure the `$original` variable is exist
        check_variable_existent_2:
            type: php
            assertTrue: variable_exists('new')
            failure: Make sure the `$new` variable is exist
        assert_instance_of_1:
            type: php
            assertTrue: is_subclass_of(get_variable('original'), '\DeathStar')
            failure: The `$original` variable exists, but is not set to a `DeathStar` object.
        assert_instance_of_2:
            type: php
            assertTrue: is_subclass_of(get_variable('new'), '\DeathStarII')
            failure: The `$new` variable exists, but is not set to a `DeathStarII` object.
        assert_instance_of_3:
            type: php
            assertTrue: is_subclass_of(get_variable('new'), '\DeathStar')
            failure: The `DeathStarII` class is not extending `DeathStar` one.
        assert_method_1:
            type: php
            assertTrue: 'Thermal Exhaust Port' === get_variable('original').getWeakness()
            failure: The return value of `getWeakness()` method in a `DeathStar` class was changed. You should override it.
        assert_method_2:
            type: php
            assertTrue: null !== get_variable('new').getWeakness()
            failure: The `getWeakness()` method of `DeathStarII` class does not return `null`.

override_calloverriddenmethodmc:
    question: >
        Look at the following classes:

        ```php
        class Ship
        {
            public function printType()
            {
                echo 'Empire Ship';

                $this->printMotto();
            }

            public function printMotto()
            {
                echo 'I like to fly!';
            }
        }
        ```

        ```php
        class RebelShip extends Ship
        {
            public function printType()
            {
                echo 'Rebel Ship';
            }
        }
        ```

        What is the result of the following code:

        ```
        $ship = new Ship();
        $rebelShip = new RebelShip();
        $ship->printType();
        $rebelShip->printType();
        ```
    explanation: >
        For `Ship`, `printType()` prints "Empire Ship" and then also
        calls `printMotto()`. But for `RebelShip`, `printType()` only
        prints "Rebel Ship". *Nothing* calls the `printMotto()`
        function in this case.
    features:
        multiple_choice:
            choices:
                a: `Empire ShipRebelShip`
                b: `Empire ShipI like to fly!RebelShip`
                c: `Empire ShipI like to fly!RebelShipI like to fly`
                d: `RebelShipRebelShip`
            correct: b

# ProtectedVisibility
protectedvisibility_getinheritedpropertycoding:
    question: >
        The construction of the `DeathStarII` continues, but we need access
        to the `planetarySuperLaserRange` property from the original, because
        we're going to make it fire twice as far! Fix the `DeathStar` class
        so that the new `getSpecs()` method works:
    step: ~
    files:
        DeathStar.php:
        DeathStarII.php: ~
            read_only: true
        index.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_property:
            type: php
            assertTrue: reflection_class('\DeathStar').hasProperty('planetarySuperLaserRange')
            failure: The `planetarySuperLaserRange` property does not exist in the `DeathStar` class.
        check_property_visibility:
            type: php
            assertTrue: reflection_class('\DeathStar').getProperty('planetarySuperLaserRange').isProtected()
            failure: The `planetarySuperLaserRange` property should have protected visibility.

protectedvisibility_propertyvisibilitymc:
    question: >
        Check out the following code:

        ```php
        // Ship.php

        class Ship
        {
            public $name;

            protected $weaponPower;

            private $defense;

            public function getDefense()
            {
                return $this->defense;
            }
        }
        ```

        ```php
        // JediShip.php

        class JediShip extends Ship
        {
            public function getWeaponPower()
            {
                return $this->weaponPower;
            }
        }
        ```

        ```php
        // index.php

        $jediShip = new JediShip();
        $jediShip->name;
        $jediShip->weaponPower;
        ```

        Which of the above code will give us an error?
    explanation: >
        Since the `$defense` property is `private`, we can only access it from
        within the `Ship` class. But that's exactly what we're doing in (B),
        so that's fine.

        The `$weaponPower` property is `protected`. That means we can access it
        only from inside `Ship`, `JediShip` or any other sub-classes. That's why
        (C) is valid. But in (A), we're accessing `weaponPower` from `index.php`.
        Accessing a property or method from outside of the class is only allowed
        if it is public. This is a bad code.
    features:
        multiple_choice:
            choices:
                a: `$jediShip->weaponPower` in `index.php`
                b: `return $this->defense` in `Ship.php`
                c: `return $this->weaponPower` in `JediShip.php`
                d: None of the above is bad code - we're awesome!
            correct: a
